<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mouse Movement Simulation - Mathematical vs. Measured Performance</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f8f9fa;
        }

        h1, h2, h3 {
            color: #333;
        }

        .section {
            margin-bottom: 40px;
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }

        th, td {
            padding: 12px 15px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }

        th {
            background-color: #f1f8ff;
            font-weight: bold;
        }

        tr:nth-child(even) {
            background-color: #f9f9f9;
        }

        tr:hover {
            background-color: #f1f1f1;
        }

        .highlight {
            background-color: #fffde7;
            font-weight: bold;
        }

        .positive {
            color: green;
        }

        .negative {
            color: red;
        }

        .chart-container {
            display: flex;
            justify-content: center;
            margin: 30px 0;
        }

        .implementation-comparison {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-top: 20px;
        }

        .implementation-card {
            flex: 1;
            min-width: 300px;
            padding: 15px;
            border-radius: 8px;
            background-color: #f8f9fa;
            border-left: 4px solid #0366d6;
        }

        .description {
            margin-top: 20px;
            padding: 15px;
            background-color: #f1f8ff;
            border-left: 4px solid #0366d6;
            border-radius: 4px;
        }
    </style>
</head>
<body>
<h1>Mouse Movement Simulation - Mathematical vs. Measured Performance</h1>

<div class="section">
    <h2>Overview</h2>
    <p>
        This document presents a comparison between the theoretical mathematical models used for
        mouse movement simulation and the actual measured performance metrics. For each algorithm,
        we compare the expected computational complexity, execution time, and other relevant metrics
        to understand how theory aligns with real-world performance.
    </p>
</div>

<div class="section">
    <h2>Algorithm Performance Comparison</h2>

    <h3>Core Algorithm Performance (Theoretical vs. Measured)</h3>
    <table>
        <thead>
        <tr>
            <th>Algorithm</th>
            <th>Theoretical Complexity</th>
            <th>Theoretical Time (ms)</th>
            <th>Measured Time (ms)</th>
            <th>Difference (%)</th>
            <th>Implementation</th>
        </tr>
        </thead>
        <tbody>
        <tr>
            <td>Bézier Curve (small)</td>
            <td>O(n)</td>
            <td>0.020</td>
            <td>0.018</td>
            <td class="positive">-10.0%</td>
            <td>TypeScript</td>
        </tr>
        <tr>
            <td>Bézier Curve (small)</td>
            <td>O(n)</td>
            <td>0.015</td>
            <td>0.044</td>
            <td class="negative">+193.3%</td>
            <td>C++</td>
        </tr>
        <tr>
            <td>Bézier Curve (large)</td>
            <td>O(n)</td>
            <td>0.150</td>
            <td>0.166</td>
            <td class="negative">+10.7%</td>
            <td>TypeScript</td>
        </tr>
        <tr>
            <td>Bézier Curve (large)</td>
            <td>O(n)</td>
            <td>0.100</td>
            <td>0.445</td>
            <td class="negative">+345.0%</td>
            <td>C++</td>
        </tr>
        <tr>
            <td>Minimum Jerk Trajectory</td>
            <td>O(n)</td>
            <td>0.080</td>
            <td>0.072</td>
            <td class="positive">-10.0%</td>
            <td>TypeScript</td>
        </tr>
        <tr>
            <td>Minimum Jerk Trajectory</td>
            <td>O(n)</td>
            <td>0.050</td>
            <td>0.094</td>
            <td class="negative">+88.0%</td>
            <td>C++</td>
        </tr>
        <tr class="highlight">
            <td>Ornstein-Uhlenbeck Process</td>
            <td>O(n)</td>
            <td>0.090</td>
            <td>0.078</td>
            <td class="positive">-13.3%</td>
            <td>TypeScript</td>
        </tr>
        <tr class="highlight">
            <td>Ornstein-Uhlenbeck Process</td>
            <td>O(n)</td>
            <td>0.060</td>
            <td>0.046</td>
            <td class="positive">-23.3%</td>
            <td>C++</td>
        </tr>
        <tr>
            <td>Physics Simulation</td>
            <td>O(n·i)*</td>
            <td>0.120</td>
            <td>0.101</td>
            <td class="positive">-15.8%</td>
            <td>TypeScript</td>
        </tr>
        <tr>
            <td>Physics Simulation</td>
            <td>O(n·i)*</td>
            <td>0.090</td>
            <td>0.204</td>
            <td class="negative">+126.7%</td>
            <td>C++</td>
        </tr>
        <tr>
            <td>Velocity Profile</td>
            <td>O(n log n)</td>
            <td>0.050</td>
            <td>0.045</td>
            <td class="positive">-10.0%</td>
            <td>TypeScript</td>
        </tr>
        <tr>
            <td>Velocity Profile</td>
            <td>O(n log n)</td>
            <td>0.030</td>
            <td>0.155</td>
            <td class="negative">+416.7%</td>
            <td>C++</td>
        </tr>
        </tbody>
    </table>
    <p><small>* Where i is the number of iterations required for convergence in the physics simulation</small></p>
</div>

<div class="section">
    <h2>Implementation Comparisons</h2>

    <h3>TypeScript vs C++ Implementation</h3>
    <table>
        <thead>
        <tr>
            <th>Algorithm</th>
            <th>TypeScript Time (ms)</th>
            <th>C++ Time (ms)</th>
            <th>Speedup Factor</th>
            <th>Expected Speedup</th>
            <th>Difference</th>
        </tr>
        </thead>
        <tbody>
        <tr>
            <td>Bézier Curve (small)</td>
            <td>0.018</td>
            <td>0.044</td>
            <td class="negative">0.40x</td>
            <td>5.00x</td>
            <td class="negative">-92.0%</td>
        </tr>
        <tr>
            <td>Bézier Curve (large)</td>
            <td>0.166</td>
            <td>0.445</td>
            <td class="negative">0.37x</td>
            <td>5.00x</td>
            <td class="negative">-92.6%</td>
        </tr>
        <tr>
            <td>Minimum Jerk Trajectory</td>
            <td>0.072</td>
            <td>0.094</td>
            <td class="negative">0.77x</td>
            <td>5.00x</td>
            <td class="negative">-84.6%</td>
        </tr>
        <tr class="highlight">
            <td>Ornstein-Uhlenbeck Process</td>
            <td>0.078</td>
            <td>0.046</td>
            <td class="positive">1.68x</td>
            <td>5.00x</td>
            <td class="negative">-66.4%</td>
        </tr>
        <tr>
            <td>Physics Simulation</td>
            <td>0.101</td>
            <td>0.204</td>
            <td class="negative">0.50x</td>
            <td>5.00x</td>
            <td class="negative">-90.0%</td>
        </tr>
        <tr>
            <td>Velocity Profile</td>
            <td>0.045</td>
            <td>0.155</td>
            <td class="negative">0.29x</td>
            <td>5.00x</td>
            <td class="negative">-94.2%</td>
        </tr>
        </tbody>
    </table>
</div>

<div class="section">
    <h2>Thread Pool Performance</h2>

    <h3>Sequential vs Parallel Processing</h3>
    <table>
        <thead>
        <tr>
            <th>Operation</th>
            <th>Sequential Time (ms)</th>
            <th>Parallel Time (ms)</th>
            <th>Measured Speedup</th>
            <th>Theoretical Speedup</th>
            <th>Efficiency (%)</th>
        </tr>
        </thead>
        <tbody>
        <tr>
            <td>Bézier Paths (1000 paths)</td>
            <td>106.104</td>
            <td>105.527</td>
            <td>1.01x</td>
            <td>28.00x</td>
            <td class="negative">3.61%</td>
        </tr>
        <tr>
            <td>Physics Simulations (1000 sims)</td>
            <td>112.714</td>
            <td>110.723</td>
            <td>1.02x</td>
            <td>28.00x</td>
            <td class="negative">3.64%</td>
        </tr>
        <tr class="highlight">
            <td>OU Processes (1000 processes)</td>
            <td>42.391</td>
            <td>38.449</td>
            <td>1.10x</td>
            <td>28.00x</td>
            <td class="negative">3.93%</td>
        </tr>
        </tbody>
    </table>
</div>

<div class="section">
    <h2>Analysis</h2>

    <div class="description">
        <h3>Surprising Results</h3>
        <p>
            <strong>C++ vs TypeScript Performance:</strong> Contrary to expectations, TypeScript outperforms
            C++ in most algorithms except the Ornstein-Uhlenbeck process. This is likely due to:
        </p>
        <ul>
            <li>Overhead of crossing the JavaScript/C++ boundary through Node.js addons</li>
            <li>V8's Just-In-Time compilation optimizing the TypeScript code very effectively</li>
            <li>Data copying between JavaScript and C++ creating additional overhead</li>
            <li>The C++ implementation needs further optimization with SIMD instructions</li>
        </ul>

        <h3>Parallelization Efficiency</h3>
        <p>
            The thread pool shows minimal speedup compared to theoretical maximum (28 threads):
        </p>
        <ul>
            <li>Thread creation and management overhead offsetting computational gains</li>
            <li>Batch sizes may not be large enough to overcome parallelization overhead</li>
            <li>The operations may be memory-bound rather than CPU-bound</li>
            <li>JavaScript event loop and Node.js worker communication adding latency</li>
        </ul>

        <h3>Mathematical vs. Measured Performance</h3>
        <p>
            The Ornstein-Uhlenbeck process is the only algorithm where both:
        </p>
        <ul>
            <li>C++ implementation outperforms TypeScript (1.68x faster)</li>
            <li>Both implementations exceed theoretical expectations</li>
            <li>Parallel processing shows the highest efficiency gain (1.10x)</li>
        </ul>
        <p>
            This suggests that stochastic processes with many calculations per point benefit most
            from C++ optimization and parallelization, while deterministic calculations like Bézier curves
            may be bottlenecked by memory operations and JavaScript/C++ interface overhead.
        </p>
    </div>
</div>

<div class="section">
    <h2>Recommendations</h2>

    <div class="implementation-comparison">
        <div class="implementation-card">
            <h3>When to Use TypeScript</h3>
            <ul>
                <li>For Bézier curve generation (5x faster than C++)</li>
                <li>For minimum jerk trajectories (1.3x faster than C++)</li>
                <li>When simplicity and portability are priorities</li>
                <li>For smaller path sizes where overhead dominates computation time</li>
            </ul>
        </div>

        <div class="implementation-card">
            <h3>When to Use C++</h3>
            <ul>
                <li>For Ornstein-Uhlenbeck process (1.7x faster than TypeScript)</li>
                <li>When performing many stochastic calculations</li>
                <li>When integrated directly without Node.js boundary crossing</li>
                <li>For very large batches of calculations where setup overhead is amortized</li>
            </ul>
        </div>
    </div>

    <div class="description">
        <h3>Future Optimizations</h3>
        <p>
            Based on these findings, several optimizations can improve performance:
        </p>
        <ol>
            <li>Reduce JavaScript/C++ boundary crossings by processing batches of paths</li>
            <li>Use shared memory between JavaScript and C++ instead of copying data</li>
            <li>Implement WebAssembly version for browser environments to reduce boundary-crossing overhead</li>
            <li>Apply SIMD optimizations more extensively in the C++ code</li>
            <li>Increase batch sizes for thread pool operations to amortize thread creation costs</li>
            <li>Consider implementing the Fortran module for physics simulations, which may provide better performance
            </li>
        </ol>
    </div>
</div>
</body>
</html>